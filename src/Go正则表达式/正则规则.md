---字符

    ".": 匹配任意一个字符
    "[]": 匹配[]内任意一个字符
    "-": 指定范围：a-z、A-Z、0-9
    "^": 去反。使用在[]内部。[^xy]8
    [[:digit:]] --> 数字 == [0-9]

---次数

    "?": 匹配前面单元出现0-1次
    "+": 匹配前面单元出现1-N次
    "*": 匹配前面单元出现0-N次
    "{N}": 精确匹配前面的单元n次
    "{N.}": 至少匹配前面的单元n次
    "{.N}": 最多匹配前面的单元n次
    "{N,M}": 最少匹配前面的单元n次，最多匹配m次

---特殊字符

    "\": 转义字符，普通字符转义为特殊字符，特殊字符转义为普通字符
    "()": 将正则表达式的一部分括起来组成一个单元，可以对整个单元使用数量限定符
          eg：([0-9][1.3]\.){3}[0-9]{1.3}匹配IP地址
    "|": 连接两个子表达式，表示或的关系

---步骤

    1.解析、编译正则表达式。使用func MustCompile(str string) *Regexp
        函数主要作用是将正则表达式中，奇形怪状的符号(.*?[]等)转化为Go语言能够识别的格式，
        并将其存成结构体格式，方便编译器识别。
    2.根据解析好的规则（结构体形式），从指定字符串中提取需要的信息。
      使用函数：func (re *Regexp) FindAllStringSubmatch(s string, n int) [][]string

---一些问题
1.在字符串中，如果遇到换行，则源正则表达式‘<div>(.*)</div>’，不能正确提取数据。因此需要调整
 正则表达式：‘<div>(?s:(.*?))</div>’。分析这个表达式，有两部分内容：
 --(?s)是正则表达式的模式修饰符，即Singleline(单行模式)，表示更改.的含义。使它与每一个字符
    匹配（包括换行符\n）
 --(.*?)是一个单元分组。"."匹配任意字符。"?"表示重复>=0次匹配
 --结论：将(?s:(.*?))元组放置于耨一特征字符串中，可以提取带有这一特征字串的内容。